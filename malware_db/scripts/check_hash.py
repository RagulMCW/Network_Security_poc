#!/usr/bin/env python3
"""
Malware Hash Checker

Standalone tool to check file hashes against malware databases.
Can be used independently or called by MCP server.
"""

import hashlib
import json
from pathlib import Path
from datetime import datetime


class MalwareHashChecker:
    
    def __init__(self, db_dir=None):
        if db_dir:
            self.db_dir = Path(db_dir)
        else:
            self.db_dir = Path(__file__).parent.parent / "hash_databases"
        
        self.databases = {
            "malwarebazaar": self.db_dir / "malwarebazaar.txt",
            "custom": self.db_dir / "custom_malware.txt",
            "eicar": self.db_dir / "eicar_test.txt"
        }
        
        # Load databases into memory
        self.hash_sets = {}
        self.hash_metadata = {}
        self._load_databases()
    
    def _load_databases(self):
        """Load all hash databases into memory"""
        for db_name, db_path in self.databases.items():
            # print(f"DEBUG: Loading {db_name} from {db_path}")
            if not db_path.exists():
                continue
            
            self.hash_sets[db_name] = {
                "md5": set(),
                "sha1": set(),
                "sha256": set()
            }
            
            with open(db_path, 'r', encoding='utf-8') as f:
                for line in f:
                    line = line.strip()
                    
                    # Skip comments and empty lines
                    if not line or line.startswith('#'):
                        continue
                    
                    parts = line.split('|')
                    
                    if db_name == "malwarebazaar":
                        # Format: SHA256|MD5|SHA1|Signature|Tags|FileType|FirstSeen
                        if len(parts) >= 3:
                            sha256 = parts[0].lower()
                            md5 = parts[1].lower()
                            sha1 = parts[2].lower()
                            
                            self.hash_sets[db_name]["sha256"].add(sha256)
                            self.hash_sets[db_name]["md5"].add(md5)
                            self.hash_sets[db_name]["sha1"].add(sha1)
                            # print(f"DEBUG: Added {sha256} to malwarebazaar")
                            
                            # Store metadata
                            metadata = {
                                "database": db_name,
                                "signature": parts[3] if len(parts) > 3 else "unknown",
                                "tags": parts[4] if len(parts) > 4 else "",
                                "file_type": parts[5] if len(parts) > 5 else "",
                                "first_seen": parts[6] if len(parts) > 6 else ""
                            }
                            
                            self.hash_metadata[sha256] = metadata
                            self.hash_metadata[md5] = metadata
                            self.hash_metadata[sha1] = metadata
                    
                    elif db_name == "eicar":
                        # Format: MD5:hash or SHA1:hash or SHA256:hash
                        if ':' in line:
                            hash_type, hash_value = line.split(':', 1)
                            hash_type = hash_type.lower()
                            hash_value = hash_value.lower()
                            
                            if hash_type in self.hash_sets[db_name]:
                                self.hash_sets[db_name][hash_type].add(hash_value)
                                self.hash_metadata[hash_value] = {
                                    "database": db_name,
                                    "signature": "EICAR Test File",
                                    "severity": "LOW"
                                }
                        else:
                            # Assume MD5 by default
                            hash_value = line.lower()
                            self.hash_sets[db_name]["md5"].add(hash_value)
                            self.hash_metadata[hash_value] = {
                                "database": db_name,
                                "signature": "EICAR Test File",
                                "severity": "LOW"
                            }
                    
                    elif db_name == "custom":
                        # Format: HASH_TYPE:HASH_VALUE|DESCRIPTION|SEVERITY
                        if ':' in parts[0]:
                            hash_type, hash_value = parts[0].split(':', 1)
                            hash_type = hash_type.lower()
                            hash_value = hash_value.lower()
                            
                            if hash_type in self.hash_sets[db_name]:
                                self.hash_sets[db_name][hash_type].add(hash_value)
                                
                                metadata = {
                                    "database": db_name,
                                    "description": parts[1] if len(parts) > 1 else "Unknown",
                                    "severity": parts[2] if len(parts) > 2 else "MEDIUM"
                                }
                                self.hash_metadata[hash_value] = metadata
    
    def compute_hashes(self, file_path):
        """Compute MD5, SHA1, SHA256 for a file"""
        try:
            md5_hash = hashlib.md5()
            sha1_hash = hashlib.sha1()
            sha256_hash = hashlib.sha256()
            
            with open(file_path, 'rb') as f:
                # Read file in chunks
                while chunk := f.read(8192):
                    md5_hash.update(chunk)
                    sha1_hash.update(chunk)
                    sha256_hash.update(chunk)
            
            return {
                "md5": md5_hash.hexdigest(),
                "sha1": sha1_hash.hexdigest(),
                "sha256": sha256_hash.hexdigest()
            }
        except Exception as e:
            return {"error": str(e)}
    
    def check_hash(self, file_hash):
        """Check if a hash exists in any database"""
        file_hash = file_hash.lower()
        matches = []
        
        for db_name, hash_types in self.hash_sets.items():
            for hash_type, hash_set in hash_types.items():
                if file_hash in hash_set:
                    metadata = self.hash_metadata.get(file_hash, {})
                    # Ensure current database name takes precedence over metadata
                    match_data = metadata.copy()
                    match_data.update({
                        "database": db_name,
                        "hash_type": hash_type,
                        "hash_value": file_hash
                    })
                    matches.append(match_data)
        
        return matches
    
    def check_file(self, file_path, check_online=False):
        """Check file hashes against databases with 2-step priority:
        1. Check EICAR test file first (immediate return if found)
        2. Check local databases (MalwareBazaar, custom)
        3. Query online API if enabled and no local match
        
        Args:
            file_path: Path to file to check
            check_online: If True, query MalwareBazaar API for unknown hashes
        
        Returns:
            Dictionary with check results
        """
        file_path = Path(file_path)
        
        if not file_path.exists():
            return {
                "status": "error",
                "message": f"File not found: {file_path}"
            }
        
        # Compute hashes
        hashes = self.compute_hashes(file_path)
        
        if "error" in hashes:
            return {
                "status": "error",
                "message": hashes["error"]
            }
        
        # STEP 1: Check if EICAR test file (highest priority)
        eicar_matches = []
        for hash_type, hash_value in hashes.items():
            if "eicar" in self.hash_sets and hash_value in self.hash_sets["eicar"][hash_type]:
                metadata = self.hash_metadata.get(hash_value, {})
                eicar_matches.append({
                    "database": "eicar",
                    "hash_type": hash_type,
                    "hash_value": hash_value,
                    "signature": metadata.get("signature", "EICAR Test File"),
                    "severity": metadata.get("severity", "LOW"),
                    "description": "EICAR Standard Anti-Virus Test File"
                })
        
        # If EICAR found, return immediately with TEST_FILE status
        if eicar_matches:
            return {
                "status": "success",
                "file_path": str(file_path),
                "file_size": file_path.stat().st_size,
                "hashes": hashes,
                "matches": eicar_matches,
                "threat_score": 10,
                "threat_level": "TEST_FILE",
                "check_stage": "EICAR_DETECTED",
                "timestamp": datetime.now().isoformat(),
                "note": "EICAR test file detected. This is not real malware."
            }
        
        # STEP 2: Check local databases (MalwareBazaar, custom)
        local_matches = []
        
        for hash_type, hash_value in hashes.items():
            matches = self.check_hash(hash_value)
            # Filter out EICAR matches (already handled)
            local_matches.extend([m for m in matches if m.get("database") != "eicar"])
        
        # Determine threat level from local matches
        threat_score = 0
        threat_level = "CLEAN"
        check_stage = "LOCAL_DATABASES"
        
        if local_matches:
            threat_score = 100
            threat_level = "MALWARE"
            
            result = {
                "status": "success",
                "file_path": str(file_path),
                "file_size": file_path.stat().st_size,
                "hashes": hashes,
                "matches": local_matches,
                "threat_score": threat_score,
                "threat_level": threat_level,
                "check_stage": check_stage,
                "timestamp": datetime.now().isoformat()
            }
            
            return result
        
        # STEP 3: Query online API if enabled and no local match
        if check_online:
            online_results = self._check_online(hashes["sha256"], hash_type="sha256")
            
            if online_results:
                check_stage = "ONLINE_API"
                
                # If found online, update threat level
                if online_results.get("found"):
                    threat_score = 100
                    threat_level = "MALWARE"
                    
                    # Create a match entry from online data
                    online_match = {
                        "database": "MalwareBazaar (Online)",
                        "hash_type": "sha256",
                        "hash_value": hashes["sha256"],
                        "signature": online_results.get("signature", "unknown"),
                        "tags": online_results.get("tags", []),
                        "file_type": online_results.get("file_type", ""),
                        "first_seen": online_results.get("first_seen", ""),
                        "reporter": online_results.get("reporter", ""),
                        "origin_country": online_results.get("origin_country", "")
                    }
                    
                    return {
                        "status": "success",
                        "file_path": str(file_path),
                        "file_size": file_path.stat().st_size,
                        "hashes": hashes,
                        "matches": [online_match],
                        "threat_score": threat_score,
                        "threat_level": threat_level,
                        "check_stage": check_stage,
                        "online_check": online_results,
                        "timestamp": datetime.now().isoformat()
                    }
        
        # No matches found anywhere
        result = {
            "status": "success",
            "file_path": str(file_path),
            "file_size": file_path.stat().st_size,
            "hashes": hashes,
            "matches": [],
            "threat_score": 0,
            "threat_level": "CLEAN",
            "check_stage": "ONLINE_API" if check_online else "LOCAL_DATABASES",
            "timestamp": datetime.now().isoformat()
        }
        
        # Include online check info even if not found
        if check_online:
            result["online_check"] = online_results
        
        return result
    
    def _check_online(self, hash_value, hash_type="sha256"):
        """Check hash against online APIs (MalwareBazaar) with API authentication
        
        Args:
            hash_value: The hash to query (MD5, SHA1, or SHA256)
            hash_type: Type of hash (default: sha256)
        
        Returns:
            Dictionary with query results from MalwareBazaar API
        """
        try:
            import requests
        except ImportError:
            return {
                "source": "MalwareBazaar",
                "error": "requests module not installed. Install with: pip install requests"
            }
        
        try:
            import os
            
            # Get API key from environment variable or use provided key
            api_key = os.getenv("MALWAREBAZAAR_API_KEY", "f5b289bbb89ad8a3483fa3548e69d43a7751e16189a2caff")
            
            # MalwareBazaar API endpoint
            url = "https://mb-api.abuse.ch/api/v1/"
            
            # Prepare request data
            data = {
                "query": "get_info",
                "hash": hash_value
            }
            
            # Set authentication header
            headers = {
                "Auth-Key": api_key
            }
            
            # Make POST request
            response = requests.post(url, data=data, headers=headers, timeout=10)
            result = response.json()
            
            # Parse response based on query_status
            query_status = result.get("query_status")
            
            if query_status == "ok":
                # Hash found in database
                data_list = result.get("data", [])
                
                if data_list and len(data_list) > 0:
                    malware_info = data_list[0]
                    
                    return {
                        "source": "MalwareBazaar",
                        "found": True,
                        "query_status": query_status,
                        "sha256_hash": malware_info.get("sha256_hash", ""),
                        "sha1_hash": malware_info.get("sha1_hash", ""),
                        "md5_hash": malware_info.get("md5_hash", ""),
                        "sha3_384_hash": malware_info.get("sha3_384_hash", ""),
                        "first_seen": malware_info.get("first_seen", ""),
                        "last_seen": malware_info.get("last_seen", ""),
                        "file_name": malware_info.get("file_name", ""),
                        "file_size": malware_info.get("file_size", 0),
                        "file_type_mime": malware_info.get("file_type_mime", ""),
                        "file_type": malware_info.get("file_type", ""),
                        "reporter": malware_info.get("reporter", ""),
                        "origin_country": malware_info.get("origin_country", ""),
                        "signature": malware_info.get("signature", "unknown"),
                        "tags": malware_info.get("tags", []),
                        "imphash": malware_info.get("imphash", ""),
                        "tlsh": malware_info.get("tlsh", ""),
                        "ssdeep": malware_info.get("ssdeep", ""),
                        "delivery_method": malware_info.get("delivery_method", ""),
                        "yara_rules": malware_info.get("yara_rules", []),
                        "vendor_intel": malware_info.get("vendor_intel", {}),
                        "data": data_list
                    }
                else:
                    return {
                        "source": "MalwareBazaar",
                        "found": False,
                        "query_status": query_status,
                        "message": "Hash found but no data available"
                    }
            
            elif query_status == "hash_not_found":
                return {
                    "source": "MalwareBazaar",
                    "found": False,
                    "query_status": query_status,
                    "message": "Hash not found in MalwareBazaar database"
                }
            
            elif query_status == "illegal_hash":
                return {
                    "source": "MalwareBazaar",
                    "found": False,
                    "query_status": query_status,
                    "error": "Invalid hash format"
                }
            
            elif query_status == "no_hash_provided":
                return {
                    "source": "MalwareBazaar",
                    "found": False,
                    "query_status": query_status,
                    "error": "No hash provided in request"
                }
            
            else:
                return {
                    "source": "MalwareBazaar",
                    "found": False,
                    "query_status": query_status,
                    "message": f"Unknown query status: {query_status}"
                }
                
        except requests.exceptions.Timeout:
            return {
                "source": "MalwareBazaar",
                "error": "Request timeout (10s)"
            }
        except requests.exceptions.RequestException as e:
            return {
                "source": "MalwareBazaar",
                "error": f"Network error: {str(e)}"
            }
        except Exception as e:
            return {
                "source": "MalwareBazaar",
                "error": f"Unexpected error: {str(e)}"
            }
    
    def get_statistics(self):
        """Get database statistics"""
        stats = {}
        
        for db_name, hash_types in self.hash_sets.items():
            stats[db_name] = {
                "md5_count": len(hash_types["md5"]),
                "sha1_count": len(hash_types["sha1"]),
                "sha256_count": len(hash_types["sha256"])
            }
        
        return stats


def main():
    import argparse
    
    parser = argparse.ArgumentParser(description="Check file hash against malware databases")
    parser.add_argument("input", help="File path or hash value to check")
    parser.add_argument("--online", action="store_true", help="Check online APIs")
    parser.add_argument("--stats", action="store_true", help="Show database statistics")
    parser.add_argument("--json", action="store_true", help="Output as JSON")
    
    args = parser.parse_args()
    
    checker = MalwareHashChecker()
    
    if args.stats:
        stats = checker.get_statistics()
        if args.json:
            print(json.dumps(stats, indent=2))
        else:
            print("üìä Malware Database Statistics")
            print("="*60)
            for db_name, counts in stats.items():
                print(f"\n{db_name}:")
                for hash_type, count in counts.items():
                    print(f"  {hash_type}: {count:,}")
        return
    
    # Check if input is a file or hash
    input_path = Path(args.input)
    
    if input_path.exists() and input_path.is_file():
        # Check file
        result = checker.check_file(input_path, check_online=args.online)
    else:
        # Check hash
        hash_value = args.input.strip()
        
        # STEP 1: Check EICAR first
        eicar_match = None
        if "eicar" in checker.hash_sets:
            for hash_type, hash_set in checker.hash_sets["eicar"].items():
                if hash_value.lower() in hash_set:
                    eicar_match = {
                        "database": "eicar",
                        "hash_type": hash_type,
                        "hash_value": hash_value.lower(),
                        "signature": "EICAR Test File",
                        "severity": "LOW"
                    }
                    break
        
        if eicar_match:
            # EICAR found - return immediately
            result = {
                "status": "success",
                "hash": hash_value,
                "matches": [eicar_match],
                "threat_level": "TEST_FILE",
                "threat_score": 10,
                "check_stage": "EICAR_DETECTED"
            }
        else:
            # STEP 2: Check local databases
            matches = checker.check_hash(hash_value)
            
            if matches:
                result = {
                    "status": "success",
                    "hash": hash_value,
                    "matches": matches,
                    "threat_level": "MALWARE",
                    "threat_score": 100,
                    "check_stage": "LOCAL_DATABASES"
                }
            else:
                # STEP 3: Online check (if enabled)
                result = {
                    "status": "success",
                    "hash": hash_value,
                    "matches": [],
                    "threat_level": "CLEAN",
                    "threat_score": 0,
                    "check_stage": "LOCAL_DATABASES"
                }
                
                if args.online:
                    # Determine hash type by length
                    hash_len = len(hash_value)
                    if hash_len == 64:  # SHA256
                        online_results = checker._check_online(hash_value, hash_type="sha256")
                    elif hash_len == 40:  # SHA1
                        online_results = checker._check_online(hash_value, hash_type="sha1")
                    elif hash_len == 32:  # MD5
                        online_results = checker._check_online(hash_value, hash_type="md5")
                    else:
                        online_results = {"error": "Invalid hash length"}
                    
                    if online_results:
                        result["online_check"] = online_results
                        result["check_stage"] = "ONLINE_API"
                        
                        if online_results.get("found"):
                            result["threat_level"] = "MALWARE"
                            result["threat_score"] = 100
                            
                            # Add online match
                            result["matches"] = [{
                                "database": "MalwareBazaar (Online)",
                                "hash_value": hash_value,
                                "signature": online_results.get("signature", "unknown"),
                                "tags": online_results.get("tags", []),
                                "file_type": online_results.get("file_type", ""),
                                "first_seen": online_results.get("first_seen", "")
                            }]
    
    # Output
    if args.json:
        print(json.dumps(result, indent=2))
    else:
        print("\n" + "="*70)
        print("üîç Malware Hash Check Results")
        print("="*70)
        
        if result.get("status") == "error":
            print(f"\n‚ùå Error: {result['message']}")
        else:
            print(f"\nFile: {result.get('file_path', args.input)}")
            
            if "hashes" in result:
                print(f"\nHashes:")
                for hash_type, hash_value in result["hashes"].items():
                    print(f"  {hash_type.upper()}: {hash_value}")
            
            matches = result.get("matches", [])
            print(f"\nMatches: {len(matches)}")
            
            if matches:
                print("\n‚ö†Ô∏è THREAT DETECTED!")
                for match in matches:
                    print(f"\n  Database: {match.get('database', 'Unknown')}")
                    print(f"  Hash Type: {match.get('hash_type', 'Unknown')}")
                    print(f"  Signature: {match.get('signature', 'Unknown')}")
                    if 'tags' in match:
                        print(f"  Tags: {match['tags']}")
            else:
                print("\n‚úÖ No matches found in local databases")
            # Check stage
            check_stage = result.get('check_stage', 'UNKNOWN')
            print(f"\nüîç Check Stage: {check_stage}")
            
            # Online check results
            if "online_check" in result:
                online = result["online_check"]
                print(f"\nüåê Online Check ({online.get('source', 'MalwareBazaar')}):")
                
                query_status = online.get('query_status', 'unknown')
                print(f"  Query Status: {query_status}")
                
                if online.get("found"):
                    print("  ‚ö†Ô∏è MALWARE FOUND IN MALWAREBAZAAR DATABASE!")
                    print(f"\n  üîç Malware Details:")
                    print(f"    Signature/Family: {online.get('signature', 'Unknown')}")
                    print(f"    File Type: {online.get('file_type', 'Unknown')} ({online.get('file_type_mime', '')})")
                    
                    tags = online.get('tags', [])
                    if tags:
                        print(f"    Tags: {', '.join(tags) if isinstance(tags, list) else tags}")
                    
                    print(f"    First Seen: {online.get('first_seen', 'Unknown')}")
                    print(f"    Last Seen: {online.get('last_seen', 'Unknown')}")
                    print(f"    Reporter: {online.get('reporter', 'Unknown')}")
                    print(f"    Origin Country: {online.get('origin_country', 'Unknown')}")
                    
                    if online.get('file_name'):
                        print(f"    Original Filename: {online.get('file_name')}")
                    
                    if online.get('file_size'):
                        print(f"    File Size: {online.get('file_size')} bytes")
                    
                    # Additional hashes
                    print(f"\n  üîë All Hashes:")
                    if online.get('sha256_hash'):
                        print(f"    SHA256: {online.get('sha256_hash')}")
                    if online.get('sha1_hash'):
                        print(f"    SHA1: {online.get('sha1_hash')}")
                    if online.get('md5_hash'):
                        print(f"    MD5: {online.get('md5_hash')}")
                    if online.get('sha3_384_hash'):
                        print(f"    SHA3-384: {online.get('sha3_384_hash')}")
                    
                    # Delivery method
                    if online.get('delivery_method'):
                        print(f"\n  üìß Delivery Method: {online.get('delivery_method')}")
                    
                    # YARA rules
                    yara_rules = online.get('yara_rules', [])
                    if yara_rules:
                        print(f"\n  üìã YARA Rules Triggered:")
                        for rule in yara_rules:
                            if isinstance(rule, dict):
                                print(f"    - {rule.get('rule_name', 'Unknown')}: {rule.get('description', '')}")
                            else:
                                print(f"    - {rule}")
                    
                    # Vendor intelligence
                    vendor_intel = online.get('vendor_intel', {})
                    if vendor_intel:
                        print(f"\n  üè¢ Vendor Intelligence:")
                        for vendor, intel in vendor_intel.items():
                            print(f"    {vendor}: {intel}")
                    
                elif online.get('error'):
                    print(f"  ‚ö†Ô∏è Error: {online['error']}")
                else:
                    print(f"  ‚úÖ Hash not found in MalwareBazaar database")
                    if query_status == 'hash_not_found':
                        print(f"  ‚ÑπÔ∏è This file is not known to MalwareBazaar")
            
            print(f"\n{'‚îÄ'*70}")
            print(f"üéöÔ∏è Final Assessment:")
            print(f"  Threat Level: {result.get('threat_level', 'UNKNOWN')}")
            print(f"  Threat Score: {result.get('threat_score', 0)}/100")
        
        print("="*70 + "\n")


if __name__ == "__main__":
    main()
